# 유튜브 쇼츠 자동화 시스템 설계 제안서

## 시스템 개요 및 아키텍처

### 1.1. 시스템 목표

자동화된 쇼츠 콘텐츠 생성, 업로드 및 성과 분석을 통해 유튜브 채널의 빠른 성장과 효율적인 수익 창출 극대화.

시스템은 크게 다음의 모듈로 구성되며, 각 모듈은 정의된 인터페이스를 통해 비동기적으로 연동됩니다.

- 수집 모듈 (Collection): 외부 소스(주로 YouTube Data API)로부터 콘텐츠 아이디어, 메타데이터, 원본 영상 정보 수집.
- 가공 모듈 (Processing): 수집된 원본 영상을 다운로드, 클립 추출, 자동 편집, 썸네일 생성 등 후처리하여 업로드 가능한 최종 쇼츠 영상 파일 및 메타데이터 생성.
- 업로드 모듈 (Upload): 생성된 최종 영상 파일과 메타데이터를 YouTube Data API를 사용하여 유튜브 채널에 업로드.
- 분석 모듈 (Analysis): 업로드된 영상의 성과 지표를 YouTube Analytics/Reporting API를 통해 수집하고 분석하여 다음 콘텐츠 전략 수립에 활용.

![](architecture_diagram_placeholder.png)

### 1.2. 전체 아키텍처:*(실제 시스템 설계 시 각 모듈 및 데이터 흐름을 상세화한 다이어그램 추가 필요)*

- 1.3. 구동 환경: GUI가 없는 리눅스 기반의 백엔드 서버 환경(예: 클라우드 인스턴스)에서 실행되도록 설계. 모든 작업은 커맨드 라인 도구(`yt-dlp`, `FFmpeg` 등)와 Python 스크립트를 통해 자동화.

## 1단계: 초기 설정 및 인증

### 2.1. 구글 계정 및 유튜브 채널 생성:

자동화 시스템 전용 신규 구글 계정 생성을 권장합니다. 이는 기존 개인 계정과의 분리 및 보안 강화를 위함입니다. 채널 생성 후 기본적인 설정(채널 이름, 설명, 프로필 이미지 등)을 완료합니다.

### 2.2. YouTube Data API 활성화:

1. Google Cloud Platform (GCP) 프로젝트 생성: GCP 콘솔에서 새로운 프로젝트를 생성합니다.
2. YouTube Data API v3 활성화: 생성된 프로젝트에서 'API 및 서비스' 메뉴로 이동하여 'YouTube Data API v3'를 검색하고 활성화합니다.
3. API 키 생성: 서버에서 데이터를 수집하거나 공개 정보를 조회하는 데 사용됩니다. '사용자 인증 정보' 메뉴에서 '사용자 인증 정보 만들기' -> 'API 키'를 선택하여 생성합니다. 보안을 위해 API 키에 적절한 API 제한 및 HTTP 리퍼러 제한을 설정하는 것이 좋습니다.
4. OAuth 2.0 클라이언트 ID 생성: 영상 업로드와 같이 채널 소유자 권한이 필요한 작업에 사용됩니다. '사용자 인증 정보 만들기' -> 'OAuth 클라이언트 ID'를 선택합니다. 애플리케이션 유형은 '데스크톱 앱' 또는 '웹 애플리케이션' (리디렉션 URI 설정 필요)으로 선택하며, 백엔드 환경에서는 '데스크톱 앱' 방식이 초기 인증 처리에 더 편리할 수 있습니다. 클라이언트 ID와 클라이언트 보안 비밀번호를 다운로드합니다.

1. 최초 인증 (로컬 환경): 시스템을 실행할 서버와 동일한 OS 환경의 로컬 머신에서 OAuth 2.0 플로우를 수동으로 완료합니다. 브라우저가 열리면 구글 계정에 로그인하고 권한을 승인합니다. 승인 완료 후 생성되는 `refresh_token`을 확보합니다.
2. `refresh_token` 서버 저장 및 활용: 확보한 `refresh_token`과 클라이언트 ID/보안 비밀번호를 사용하여 새로운 `access_token`을 주기적으로 발급받습니다. 이 `refresh_token`은 보안된 서버 환경에 안전하게 저장해야 합니다. 시스템은 이 `refresh_token`을 사용하여 GUI 개입 없이 API 요청 시 필요한 `access_token`을 자동으로 갱신하고 사용합니다.

### 2.3. 백엔드 인증 처리: GUI 없는 환경에서 OAuth 2.0 인증을 처리하기 위해 `google-auth-oauthlib` 라이브러리를 사용합니다.

## 2단계: 핵심 자동화 워크플로우 설계 (The Core Loop)

### 3.1. [1] 콘텐츠 탐색 및 수집:

- 기술: `google-api-python-client`, YouTube Data API v3 (`search.list` 엔드포인트)
- 전략: 특정 니치(Niche)와 관련된 키워드를 선정하고, `search.list` 엔드포인트를 활용하여 인기 있는 쇼츠 영상을 탐색합니다. `videoDuration='short'`, `eventType='completed'`, `order='viewCount'` 등의 필터를 조합하여 최신 인기 쇼츠 목록을 주기적으로(예: 매 시간) 수집합니다. 수집된 영상의 ID, 제목, 원본 URL, 조회수 등의 메타데이터를 데이터베이스에 저장하고, 이미 처리한 영상은 제외하도록 관리합니다.
- 구현: Python 스크립트에서 API 키를 사용하여 `youtube.search().list(...)` 메서드를 호출하고, 응답 결과를 파싱하여 DB에 저장하는 함수를 구현합니다.

### 3.2. [2] 영상 클립 다운로드 및 추출:

- 기술: `yt-dlp`, `FFmpeg`, Python `subprocess` 모듈
- 전략: 수집 단계에서 DB에 저장된 영상 ID 목록을 순회하며, 각 영상에 대해 `yt-dlp` 라이브러리를 사용하여 최고 화질로 영상을 다운로드합니다. 다운로드된 영상 파일에서 핵심 내용이 포함될 가능성이 높은 특정 구간(예: 영상 길이의 40% ~ 60%)을 설정하고, `FFmpeg` 커맨드를 `subprocess` 모듈로 실행하여 해당 구간만 정확하게 잘라냅니다(trimming).
- 구현:
Python에서는 `subprocess.run()` 함수를 사용하여 위와 같은 커맨드를 동적으로 생성 및 실행하는 함수를 작성합니다.
    
    ```bash
    # yt-dlp 예시: 영상 다운로드 (최고 화질, mp4 포맷)
    yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --merge-output-format mp4 "<https://www.youtube.com/watch?v=><video_id>" -o "downloads/%(id)s.%(ext)s"
    
    # FFmpeg 예시: 영상 자르기 (00:05부터 00:15까지)
    ffmpeg -i input.mp4 -ss 00:05 -to 00:15 -c copy output_clip.mp4
    
    ```
    

### 3.3. [3] 클립 자동 편집 (짜깁기):

- 기술: `MoviePy`, `FFmpeg`, Python
- 전략: 다운로드 및 추출된 여러 짧은 클립(예: 3~5개)을 선정하여 순서대로 이어 붙여(concatenate) 하나의 쇼츠 영상으로 만듭니다. 채널의 정체성을 나타내는 짧은 인트로/아웃트로 클립(사전에 제작)을 영상의 시작과 끝에 추가합니다. `MoviePy`의 `TextClip`을 사용하여 영상 내용에 맞는 자막을 오버레이하고, `AudioFileClip`을 사용하여 저작권 문제가 없는 배경음악을 삽입합니다.
- 구현: `moviepy.editor` 모듈을 사용하여 `Clip.concatenate_videoclips()`, `clip.set_audio()`, `CompositeVideoClip([...])` 등의 메서드를 활용한 편집 로직을 구현합니다. 자막 생성 로직은 클립 내용이나 소스 메타데이터를 기반으로 자동화합니다.

### 3.4. [4] 자동 썸네일 생성:

- 기술: `OpenCV`, `Pillow (PIL)`, Python
- 전략: 최종 편집된 영상 파일의 길이 중앙 지점 또는 시각적으로 중요한 프레임(예: 가장 활동적인 장면)을 `OpenCV`를 사용하여 추출합니다. 추출된 이미지에 `Pillow` 라이브러리를 사용하여 영상의 핵심 내용이나 후킹성 문구를 텍스트 오버레이로 추가하여 썸네일을 자동 생성합니다.
- 구현: `cv2.VideoCapture`로 영상을 로드하고 `set(cv2.CAP_PROP_POS_FRAMES, frame_number)`로 특정 프레임을 가져온 후 `cv2.imwrite`로 저장합니다. 저장된 이미지를 `PIL.Image.open`으로 열고 `PIL.ImageDraw.Draw`를 사용하여 텍스트를 그립니다.

### 3.5. [5] 자동 업로드:

- 기술: `google-api-python-client`, YouTube Data API v3 (`videos.insert` 엔드포인트), OpenAI API (선택 사항)
- 전략: 편집 완료된 영상 파일과 함께 업로드에 필요한 제목, 설명, 태그 등의 메타데이터를 생성합니다. 제목과 설명은 원본 영상의 정보, 사용된 키워드, 채널 컨셉 등을 조합하여 생성합니다. 보다 창의적인 제목/설명 생성을 위해 OpenAI GPT API 등을 활용하는 방안을 고려할 수 있습니다. `videos.insert` 엔드포인트를 사용하여 영상을 업로드하며, `privacyStatus`를 `private`으로 설정하여 먼저 업로드한 후, 수동 또는 추가적인 검토 로직을 거쳐 `public`으로 전환하는 방식을 통해 안정성을 확보합니다.
- 구현: `googleapiclient.discovery.build`로 YouTube API 서비스를 빌드하고, `youtube.videos().insert(...)` 메서드를 사용하여 미디어 파일과 함께 메타데이터(snippet, status 등)를 JSON 형식으로 구성하여 요청을 보냅니다.

### 3.6. [6] 성과 분석 및 피드백 루프:

- 기술: YouTube Analytics API, YouTube Reporting API
- 전략: 업로드된 영상의 `video_id`를 관리하고, 주기적으로 (예: 매일) YouTube Analytics API를 통해 각 영상의 조회수, 시청 지속 시간, 노출 수, 클릭률(CTR) 등 주요 성과 지표를 수집합니다. 수집된 데이터를 분석하여 어떤 유형의 콘텐츠나 키워드가 성과가 좋은지 파악하고, 이를 다음 콘텐츠 탐색/생성 단계에 반영하는 피드백 루프를 구축합니다. (예: 성과가 좋은 영상의 키워드를 다음 탐색 시 우선순위로 설정).
- 구현: `google-api-python-client`를 사용하여 Analytics API에 접속하고, 특정 기간 및 영상에 대한 리포트를 요청하여 데이터를 가져오는 스크립트를 구현합니다.

## 3단계: 기술 스택 및 구현 가이드

### 4.1. 추천 언어: Python - 다양한 자동화 및 데이터 처리 라이브러리, 방대한 커뮤니티 지원, API 연동 용이성 등 자동화 시스템 구축에 가장 적합합니다.

### 4.2. 핵심 라이브러리:

- `google-api-python-client`: 구글 서비스(YouTube Data/Analytics API) 연동
- `google-auth-oauthlib`: OAuth 2.0 인증 처리
- `yt-dlp`: 유튜브 영상 다운로드 (커맨드 실행 필요)
- `ffmpeg-python` 또는 `subprocess` 모듈: `FFmpeg` 커맨드 실행 및 파이핑 처리
- `moviepy`: 영상 클립 편집, 합성, 효과 적용
- `Pillow` (PIL): 이미지(썸네일) 처리, 텍스트 오버레이
- `opencv-python`: 비디오 프레임 추출

### 4.3. 실행 환경:

- 스크립트 실행 자동화: 리눅스 서버에서는 `cron`을 사용하여 정해진 시간에 주기적으로 Python 스크립트를 실행하도록 설정합니다. Python 내부에서는 `APScheduler`와 같은 라이브러리를 사용하여 더욱 유연하고 동적인 스케줄링이 가능합니다.
- 종속성 관리: `virtualenv` 또는 `conda`를 사용하여 Python 환경 및 라이브러리 종속성을 관리합니다.
- FFmpeg/yt-dlp 설치: 서버에 `FFmpeg`와 `yt-dlp` 실행 파일이 설치되어 있어야 합니다.

## 4단계: 수익화 및 성장 전략

### 5.1. 유튜브 파트너 프로그램(YPP) 가입 조건 달성 전략:

- 콘텐츠: 자동화 시스템은 특정 니치에 집중하여 유사한 주제의 영상을 대량 생산함으로써 해당 분야의 채널 전문성을 빠르게 구축하는 데 유리합니다. '동기부여 명언', '역사 속 순간', 'AI 활용 팁 요약' 등 명확한 컨셉 설정이 중요합니다.
- 업로드 주기: 자동화의 장점을 활용하여 초기에는 하루 최소 2-3개의 쇼츠를 꾸준히, 장기적으로 업로드하여 유튜브 알고리즘의 노출 기회를 지속적으로 확보합니다. 양적 성장을 통해 빠르게 시청 시간 및 구독자 수를 확보하는 전략입니다.

### 5.2. 저작권 이슈 회피를 위한 리믹스 전략 (매우 중요):

- 원칙: 단순히 원본 영상을 편집 없이 재업로드하는 것은 명백한 저작권 침해입니다. 유튜브의 '공정 이용(Fair Use)' 원칙에 따라 원본 콘텐츠에 상당한 수준의 '변형(Transformation)'을 가해야 합니다. 자동화 시스템으로 구현 가능한 주요 변형 방법은 다음과 같습니다.
- 구체적 방법론 (자동화 구현 가능):
    1. 화면 구성 변경: 원본 영상을 메인으로 사용하되, 화면의 일부 공간(예: 좌우 또는 하단)에 추가 정보(예: 출처 표기, 관련 통계, 자막 해설)를 제공하는 별도의 이미지나 텍스트 레이어를 오버레이합니다. `MoviePy`로 구현 가능합니다.
    2. 음성 변조 및 해설 추가 (Voiceover): 원본 영상의 사운드를 제거하거나 줄이고, 영상 내용에 대한 비평, 해설, 추가 정보 등을 제공하는 새로운 오디오 트랙을 합성하는 것이 가장 효과적인 변형 방법 중 하나입니다. 이는 자동화 시스템에서 텍스트-음성 변환(TTS) 기술을 활용하여 구현하거나, 스크립트 기반으로 오디오 파일을 생성하여 `MoviePy`로 합성할 수 있습니다.
    3. 다중 소스 몽타주: 여러 개의 짧은 원본 클립(1~3초)을 빠르게 교차 편집하여 새로운 내러티브나 유머러스한 효과를 만듭니다. 이는 각 클립 자체보다는 편집의 흐름과 조합을 통해 변형을 꾀하는 방식입니다. `MoviePy`의 클립 연결 기능을 활용합니다.
    4. 필터 및 효과: 영상 전체에 독자적인 색감 필터, 시각 효과, 또는 속도 조절(느리게/빠르게) 등을 적용하여 원본과 다른 시각적 느낌을 줍니다. `MoviePy`나 `FFmpeg` 필터를 활용하여 자동화할 수 있습니다.
- 경고: 위 방법들은 저작권 회피 가능성을 높이지만, 저작권자의 신고나 유튜브의 자동 감지 시스템에 의해 문제가 발생할 가능성을 100% 배제할 수는 없습니다. 수익 창출이 중단되거나 채널이 삭제될 위험이 존재함을 인지해야 합니다.

### 5.3. 알고리즘 노출 증대 전략:

- 초반 1-2초의 중요성: 시청자가 쇼츠를 스와이프하지 않고 계속 시청하도록, 영상 시작 부분에 가장 흥미롭거나 핵심적인 장면, 또는 시청자의 호기심을 자극하는 요소(질문, 예상치 못한 장면 등)를 배치하도록 자동 편집 로직을 설계합니다.
- 완벽한 루프(Perfect Loop): 영상의 끝 부분이 자연스럽게 시작 부분으로 이어지도록 편집하여 시청자가 영상이 반복되고 있다는 것을 인지하지 못하고 계속 시청하게 만드는 기법입니다. 이는 시청 지속 시간 증가에 크게 기여할 수 있습니다. 특정 구간 반복 편집이나 장면 전환 기법으로 구현할 수 있습니다.
- 트렌딩 오디오 활용: (완전 자동화는 복잡) 유튜브에서 유행하는 사운드를 배경음악으로 사용하면 노출에 유리할 수 있습니다. 자동화 시스템에서 주기적으로 인기 사운드 목록을 수집하고, 이를 영상 제작 시 배경음악으로 우선 활용하도록 설정하는 부분 자동화 방안을 고려할 수 있습니다.
